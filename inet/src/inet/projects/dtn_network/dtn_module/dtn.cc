#include "inet/projects/dtn_network/dtn_module/dtn.h"
#include "inet/projects/dtn_network/dtn_states/DtnNeighborState.h"
#include "inet/common/IProtocolRegistrationListener.h"
#include "inet/common/Protocol.h"
#include "inet/projects/dtn_network/uuid/uuid4.h"
#include "inet/projects/dtn_network/const_vars/DtnConst.h"
#include "inet/networklayer/common/InterfaceTable.h"
#include "inet/networklayer/ipv4/Ipv4InterfaceData.h"
#include "inet/projects/dtn_network/dtn_packets/EpidemicHeader_m.h"
#include <fstream>
#include "inet/projects/dtn_network/tools/tools.h"

namespace inet {
    Define_Module(dtn);

    /**
        finish and record the result of the simulation
     */
     void dtn::finish(){
        // check the existance of the output path
        if(!isFolderExist(this->output_dir_path))
        {
            // create the output folder
            std::string command = "mkdir -p " + this->output_dir_path;
            system(command.c_str());
        }

        // create the output file
        std::ofstream output_file;
        output_file.open(this->output_dir_path + "/dtn_result.txt", std::ios::out | std::ios::app);

        // write the result
        std::string packet_line = "total packet received: " + std::to_string(this->total_packet_received);
        std::string delay_line = "total packet delay: " + std::to_string(this->total_packet_delay);
        output_file << module_log(this, packet_line) << std::endl;
        output_file << module_log(this, delay_line) << std::endl;

        // close the file
        output_file.close();
     }

    /**
     * destructor
     */
    dtn::~dtn(){
        // we need to delete the packet inside the packet buffer
        for(const auto& packet : this->packets_buffer){
            if(packet.second.first->getOwner()->getFullPath() == this->getFullPath()){
                delete packet.second.first;
                std::cout << module_log(this, "delete packet belong to dtn module") << std::endl;
            }
            else{
                if(packet.second.first->getOwner() == this->getParentModule()->getSubmodule("dtnTraffic"))
                {
                    // take the ownership of the packet belong to dtnTraffic module
                    this->take(packet.second.first);
                    delete packet.second.first;
                    std::cout << module_log(this, "delete packet belong to dtnTraffic module") << std::endl;
                }
            }
        }
        // traverse all the neighbors
        for(const auto& neighbor : this->neighbor_map){
            // delete neighbor detection timer
            if(neighbor.second->neighborDetectTimer->isScheduled()){
                // cancelEvent is executed here because the event is generated by the dtn_module's message handler
                cancelEvent(neighbor.second->neighborDetectTimer);
            }
            // delete neighbor expire timer
            if(neighbor.second->neighborExpireTimer->isScheduled()){
                // cancelEvent is executed here because the event is generated by the dtn_module's message handler
                cancelEvent(neighbor.second->neighborExpireTimer);
            }
            // delete check neighbor exchange timer
            if(neighbor.second->neighborExchangeTimer->isScheduled()){
                // cancelEvent is executed here because the event is generated by the dtn_module's message handler
                cancelEvent(neighbor.second->neighborExchangeTimer);
            }
            // delete neighbor send packet timer
            if(neighbor.second->neighborSendPacketTimer->isScheduled()){
                // cancelEvent is executed here because the event is generated by the dtn_module's message handler
                cancelEvent(neighbor.second->neighborSendPacketTimer);
            }
            delete neighbor.second;
        }
        // we need to delete the message handler
        delete this->messageHandler;
        // we need to cancel the event start by the dtn module
        if(this->check_buffer_expired_timer->isScheduled()){
            cancelEvent(this->check_buffer_expired_timer);
        }
        // we need to delete the timer: start timer and check buffer expired timer
        if(this->check_buffer_expired_timer != nullptr){
            delete this->check_buffer_expired_timer;
        }
    };

    /**
     * generate a uuid
     * @return string uuid
     */
    std::string dtn::generateUuid() {
        char buf[UUID4_LEN];
        uuid4_init();
        uuid4_generate(buf);
        return std::string(buf);
    }

    /**
     * initialize the dtn neighbors / we will generate neighbor for each interface
     */
    void dtn::initializeNeighbors(){
        // get interface table of the current node
        auto* ift = dynamic_cast<InterfaceTable*>(this->getParentModule()->getSubmodule(INTERFACE_TABLE_NAME.c_str()));
        // traverse all the interfaces except loopback interface
        for(auto interface : ift->idToInterface){
            // get interfaceName
            std::string interfaceName = interface->getInterfaceName();
            // if the interface name contains loopback, then we skip it
            if(interfaceName.find(LOOPBACK_INTERFACE_NAME) != std::string::npos){
                continue;
            } else {
                // generate uuid
                std::string uuid = dtn::generateUuid();
                // create a new neighbor
                auto* neighbor = new DtnNeighbor(uuid,
                                                 interface,
                                                  this, // why can we past dtn* to cSimpleModule*? because dtn is a subclass of cSimpleModule
                                                  this->neighbor_detection_interval,
                                                  this->neighbor_expiration_time,
                                                  this->check_neighbor_expiration_interval,
                                                  this->buffer_expiration_time,
                                                  this->check_buffer_expiration_interval,
                                                  this->neighbor_exchange_interval,
                                                  this->send_packet_interval);
                // add the neighbor to the neighbor map
                this->neighbor_map[uuid] = neighbor;
            }
        }
    }

    /**
     * let all the neighbors interface up
     */
    void dtn::allNeighborsInterfaceUp() {
        // traverse all the neighbors
        for(auto neighbor : this->neighbor_map){
            // process event
            neighbor.second->processEvent(DtnNeighbor::DTN_INTERFACE_UP);
        }
    }

    /**
     * let all the interfaces except loopback interface join the multicast group
     */
    void dtn::allInterfacesJoinMulticastGroups() {
        // get the interface table of this node
        auto* interfaceTable = dynamic_cast<InterfaceTable*>(this->getParentModule()->getSubmodule(INTERFACE_TABLE_NAME.c_str()));
        // traverse the interface table to get all the interfaces
        for(auto interface : interfaceTable->idToInterface){
            // get the interface name
            std::string interfaceName = interface->getInterfaceName();
            // if the interface name contains loopback, then we skip it
            if(interfaceName.find(LOOPBACK_INTERFACE_NAME) != std::string::npos){
                continue;
            } else {
                // join the multicast group
                auto ipv4Data = interface->getProtocolDataForUpdate<Ipv4InterfaceData>();
                ipv4Data->joinMulticastGroup(Ipv4Address::DTN_NEIGHBOR_DETECTION_MCAST);
            }
        }
    }

    /**
     * find neighbor by interfaceid
     * @param interfaceId
     * @return
     */
    DtnNeighbor* dtn::findNeighborByInterfaceId(int interfaceId) {
        for(const auto& neighbor : this->neighbor_map){
            if(neighbor.second->interface->getInterfaceId() == interfaceId){
                return neighbor.second;
            }
        }
        return nullptr;
    }

    /**
     * handle the start operation
     * @param operation
     */
    void dtn::handleStartOperation(LifecycleOperation *operation) {
        // generate a start msg and schedule it
        this->dtn_start_msg = new cMessage(DTN_START_MSG_NAME.c_str(), DTN_START_MSG_KIND);
        scheduleAt(simTime(), this->dtn_start_msg);
        // generate a check buffer expired timer and schedule it
        this->check_buffer_expired_timer = new cMessage(CHECK_BUFFER_EXPIRE_MSG_NAME.c_str(), CHECK_BUFFER_EXPIRED_MSG_KIND);
        scheduleAt(simTime(), this->check_buffer_expired_timer);
    }

    void dtn::handleStopOperation(LifecycleOperation *operation) {
    }

    void dtn::handleCrashOperation(LifecycleOperation *operation) {
    }

    /**
     * handle the message when up
     * @param msg
     */
    void dtn::handleMessageWhenUp(cMessage *msg) {
        this->messageHandler->messageReceived(msg);
    }

    /**
     * check the buffer expired
     */
    void dtn::checkBufferExpired(){
        // traverse the packets buffer
        for(auto iter = this->packets_buffer.begin(); iter != this->packets_buffer.end(); ){
            // if the packet exists time is larger than the buffer expiration time (expired)
            if((simTime() - iter->second.second) > this->buffer_expiration_time){
                // then we gonna delete the packet
                delete iter->second.first;
                // then we gonna delete the item
                iter = this->packets_buffer.erase(iter);
            } else {
                iter++;
            }
        }
    }

    void dtn::initialize(int stage) {
        OperationalBase::initialize(stage);
        // there are so many stages, we only setting our parameters in the local stage
        if(stage == INITSTAGE_LOCAL){
            this->neighbor_detection_interval = par(PAR_NEIGHBOR_DETECTION_INTERVAL.c_str()).doubleValue();
            this->neighbor_expiration_time = par(PAR_NEIGHBOR_EXPIRATION_TIME.c_str()).doubleValue();
            this->check_neighbor_expiration_interval = par(PAR_CHECK_NEIGHBOR_EXPIRATION_INTERVAL.c_str()).doubleValue();
            this->buffer_expiration_time = par(PAR_BUFFER_EXPIRATION_TIME.c_str()).doubleValue();
            this->check_buffer_expiration_interval = par(PAR_CHECK_BUFFER_EXPIRATION_INTERVAL.c_str()).doubleValue();
            this->neighbor_exchange_interval = par(PAR_NEIGHBOR_EXCHANGE_INTERVAL.c_str()).doubleValue();
            this->send_packet_interval = par(PAR_SEND_PACKET_INTERVAL.c_str()).doubleValue();
            this->messageHandler = new MessageHandler(this);
            this->output_dir_path = par(PAR_OUTPUT_DIR_PATH.c_str()).stdstringValue();
        }
        else if(stage == INITSTAGE_ROUTING_PROTOCOLS){
            registerProtocol(Protocol::dtn, gate("ipOut"), gate("ipIn"));
        }
    }

}
